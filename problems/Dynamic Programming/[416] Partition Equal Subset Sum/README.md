## 416. Partition Equal Subset Sum

要讓兩個子集合的和相等，我們可以先計算出所有元素的總和，然後將總和除以 2，這樣我們就可以把問題轉化為找出一個子集合，使得它的和等於總和的一半。

接著我們可以看成是 0/1 背包問題，對於每一個元素，我們可以選擇要不要算入子集合中，背包問題其實就是改變“解答空間”，如果我們建構任意和為 s 的子集合，是否能夠實現目標。對於 s 而言，他的範圍在 0 到總和的一半之間，我們有兩種 DP 方式來解這道題：

#### 二維 DP

定義 `dp[i][s]` 為前 i 個元素中是否存在和為 s 的子集合。

使用二維陣列來解又可以分成兩種方式來推導，從先前的狀態來導出目前的狀態，或是從目前的狀態導出下一步的狀態。

第一種方式：每個數字有「選擇」或「不選擇」兩種狀態，逐步遞推。

狀態轉移式為：

```ts
dp[i][s] = dp[i - 1][s] || (s >= nums[i] && dp[i - 1][s - nums[i]])
```

1. 不選擇第 `i` 個數字，則會延續前一個狀態 `dp[i - 1][s]`。
2. 選擇第 `i` 個數字，則會從前一個狀態 `dp[i - 1][s - nums[i]]` 轉移過來。

第二種方式：對於每一個可能達成的和，直接更新包含目前數字的下一步狀態。

狀態轉移式為：

若 `dp[i][s]` 為 true，那麼：

```ts
dp[i + 1][s] = true
dp[i + 1][s + nums[i+1]] = true
```

如果在檢查 `nums[i+1]` 之前，就已經可以湊出 `s`，那麼加上 `nums[i+1]` 就一定可以湊出和為 `s + nums[i+1]` 的子集合。

#### 一維 DP

定義 `dp[s]` 為是否存在和為 s 的子集合。

對於 `nums[i]`，有兩種情況：

1. 不選擇 `nums[i]`：如果之前已經可以達成和為 `s`，那麼現在也可以達成。

```ts
dp[s] = dp[s] // 沿用前一層的狀態
```

2. 選擇 `nums[i]`：如果之前已經可以達成和為 `s - nums[i]`，那麼加上目前的 `nums[i]` 就可以達成和為 `s`。

```ts
dp[s] = dp[s - nums[i]]
```

合併公式為：

```ts
dp[s] = dp[s] || dp[s - nums[i]]
```

初始化 `dp[0]` 為 true，因為空集合的和為 0。其他的 `dp[s]` 都初始化為 false。

最後在遍歷 `s` 的時候需要倒序遍歷，確保同個數字在同一輪不會被重複使用。
