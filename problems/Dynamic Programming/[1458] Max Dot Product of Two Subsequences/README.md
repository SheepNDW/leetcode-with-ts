## 1458. Max Dot Product of Two Subsequences

這題給兩個整數陣列 `nums1` 與 `nums2`，要我們找出兩個陣列的子序列，使得這兩個子序列的點積（dot product）最大化。點積的定義是對應位置的元素相乘後再相加，例如兩個子序列 `[a1, a2, ..., ak]` 和 `[b1, b2, ..., bk]` 的點積為 `a1*b1 + a2*b2 + ... + ak*bk`。

#### 解題思路

這是一道典型的雙序列型 DP。我們定義一個二維 DP 陣列 `dp[i][j]`，表示在 `nums1` 的前 `i` 個元素和 `nums2` 的前 `j` 個元素中，所能得到的最大點積。然後觀察 `nums[i]` 和 `nums2[j]` 的關係，我們有以下幾種情況：

1. `nums1[i]` 和 `nums2[j]` 配成一對，那麼 `dp[i][j] = dp[i-1][j-1] + nums1[i] * nums2[j]`。不過要注意當 `dp[i-1][j-1] < 0` 時，該項其實應該去掉，只用 `nums1[i] * nums2[j]`。
2. 不配成一對，也就是只取 `nums1[i]` 或是 `nums2[j]`，所以 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

觀察出狀態轉移方程式後，我們就可以用兩層迴圈來填滿整個 DP 陣列，最後 `dp[m][n]` 就是我們要的答案，其中 `m` 和 `n` 分別是 `nums1` 和 `nums2` 的長度。

#### 實作細節

初始化 `dp` 陣列時，我們可以將所有值設為一個非常小的數（例如負無限大），而邊界的 `dp[0][j]` 和 `dp[i][0]` 都設為負無限大，這樣一來空序列自然就不會是最佳解，所以不會影響結果。

此外我們讓 dp 使用 1-based index（`dp[i][j]` 對應前 `i` / 前 `j`），陣列仍維持 0-based，因此取值時用 `nums1[i-1]` 與 `nums2[j-1]`。
