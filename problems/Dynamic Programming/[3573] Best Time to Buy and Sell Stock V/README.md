## 3573. Best Time to Buy and Sell Stock V

題目給了一個整數陣列 `prices`，其中 `prices[i]` 是第 `i` 天的股票價格，還有一個整數 `k`，表示你最多可以進行 `k` 筆交易。

有兩種交易方式：

1. normal transaction: 在 `i` 天買入股票，並在 `j` 天賣出股票，且 `i < j`。
2. short selling transaction: 在 `i` 天賣出股票（尚未持有），並在 `j` 天買回股票，且 `i < j`。

限制是：

* 最多進行 `k` 筆交易。
* 每筆交易都要在開始前結束前一筆交易（也就是說，交易之間不能重疊）。
* 同一天內不能同時進行買入和賣出操作。

求在這些限制下，最多進行 `k` 次交易所能獲得的最大利潤。

例如：

```ts
prices = [1, 7, 9, 8, 2], k = 2
```

最佳解為：

1. 在第 0 天以價格 1 買入，並在第 2 天以價格 9 賣出，獲得利潤 8。
2. 在第 3 天以價格 8 賣出（做空），並在第 4 天以價格 2 買回，獲得利潤 6。

總利潤為 8 + 6 = 14。

#### 思路

使用動態規劃來解決這個問題。我們定義 `dp[i][t][s]` 表示在第 i 天結束時，進行了 t 筆交易，且狀態為 s 時的最大利潤：

* `s = 0`: 空手狀態
* `s = 1`: 持有多單狀態
* `s = 2`: 持有空單狀態

因為交易不能重疊且最後不應持倉，所以答案取結束時 `s=0`（空手）的最大利潤。因此可以推導出以下的轉移方程：

```ts
dp[i][t][0] = max(
  dp[i-1][t][0],          // 保持空倉
  dp[i-1][t][1] + prices[i], // 平多
  dp[i-1][t][2] - prices[i]  // 平空
)

dp[i][t][1] = max(
  dp[i-1][t][1],          // 維持多單
  dp[i-1][t-1][0] - prices[i] // 從空手開多（交易數+1）
)

dp[i][t][2] = max(
  dp[i-1][t][2],          // 維持空單
  dp[i-1][t-1][0] + prices[i] // 從空手開空（交易數+1）
)
```

然後針對 `s` 的三種狀態，我們可以拆出來：

* `flat[t]`: 截至目前進行了 t 筆交易，且空手時的最大利潤
* `long[t]`: 截至目前進行了 t 筆交易，且手上握有多單時的最大利潤
* `short[t]`: 截至目前進行了 t 筆交易，且手上握有空單時的最大利潤

初始化三個陣列，並把初始值設為負無限大（表示不可能的狀態），然後把 `flat[0]` 設為 0（表示沒有交易且空手的利潤為 0）。

然後開始遍歷每一天的價格，並更新這三個陣列：

```ts
for (const p of prices) {
  const newFlat = [...flat];
  const newLong = [...long];
  const newShort = [...short];

  for (let t = 0; t <= k; t++) {
    // 保持空倉 or 平倉
    newFlat[t] = Math.max(flat[t], long[t] + p, short[t] - p);

    if (t >= 1) {
      // 開多
      newLong[t] = Math.max(long[t], flat[t - 1] - p);
      // 開空
      newShort[t] = Math.max(short[t], flat[t - 1] + p);
    }
  }

  flat = newFlat;
  long = newLong;
  short = newShort;
}
```

最後答案就是所有空倉狀態下的最大利潤，也就是 `flat` 裡最大的值。

整體時間複雜度為 `O(n * k)`，其中 `n` 是價格陣列的長度，`k` 是最多交易次數。
