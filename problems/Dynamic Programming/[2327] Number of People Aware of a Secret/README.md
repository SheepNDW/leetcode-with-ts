## 2327. Number of People Aware of a Secret

#### 解法 1：`O(n * forget)` DP

這題用 DP 解的難點在於如何去設計狀態變數，如果用 `dp[i]` 代表第 `i` 天知道秘密的人數，情況會比較複雜，因為會分成新知道秘密的人數以及之前就知道秘密的人數，且之前知道秘密的人數還要扣掉忘記秘密的人數。

因此，我們可以用 `dp[i]` 代表第 `i` 天「新」知道秘密的人數，那麼根據題意，在第 `i+delay` 天直到第 `i+forget-1` 天這段期間，每天都會固定增加 `dp[i]` 人知道秘密，也就是：

```ts
for (let j = i + delay; j < i + forget; j++) {
  dp[j] += dp[i];
}
```

而初始條件為 `dp[1] = 1`，代表第一天有一個人知道秘密。

有了這個 dp 我們可以做什麼呢？答案是求在第 `n` 天還記得秘密的人數，而事實上我們只需要把每天新知道且在第 `n` 天還記得秘密的人數加總起來即可，也就是 `i + forget > n` 的 `dp[i]`。


#### 解法 2：`O(n)` 差分陣列

從上面的狀態轉移式可以發現，在一個區間內賦值同一個值的情況，用迴圈跑會是很低效的方法，這時候我們可以加入一個差分陣列。

定義 `diff[i]` 為 `dp[i]` 相比於 `dp[i-1]` 之間的增量，然後 `dp[i] = dp[i-1] + diff[i]`。然後我們可以把區間賦值的部分改寫成：

```ts
diff[i + delay] += dp[i];
diff[i + forget] -= dp[i];
```

最後 diff 初始條件，我們要把原本的 `dp[1] = 1` 轉換成 diff 的形式，也就是 `diff[1] += 1` 以及 `diff[2] -= 1`。我們先把 `diff[1]` 設成 1，代表第一天比第零天多一個人知道秘密，而 `diff[2]` 設成 -1，代表第二天比第一天少一個人知道秘密（因為只有第一天有一個人知道秘密）。後續就由 `[i+delay:i+forget]` 的區間來調整 diff 陣列。
