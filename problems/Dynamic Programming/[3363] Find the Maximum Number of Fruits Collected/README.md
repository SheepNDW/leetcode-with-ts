## 3363. Find the Maximum Number of Fruits Collected

首先分別將從 (0, 0)、(0, n-1)、(n-1, 0) 三個點出發的小孩稱為 A、B、C。

我們首先看到 A，在只能移動 n-1 步的情況下，A 要走到 (n-1, n-1) 的話，他只有一種路徑，就是從左上角走到右下角，我們只要將這條主對角線上的水果數量加起來就是 A 能收集到最多的水果數量。

接下來看到從右上角出發的 B，我們可以發現 B 只能在對角線的右側走動且無法跨越對角線，因為如果 B 跨越對角線的話，剩餘的步數會讓他無法在 n-1 步內走到 (n-1, n-1)。這個限制同樣適用於從左下角出發的 C。

此外除了 (n-1, n-1) 這個點之外，他們彼此間不會進到相同的格子，所以我們只要分開考慮 B 和 C 的路徑即可。

從右上角的 B 開始不經過對角線，找出 B 到達房間 (n−2,n−1) 時可以收集到的最大水果數量。我們可以用一個二維陣列 `dp_B` 來記錄。

- `dp_B[i][j]` 表示 B 在 (i, j) 位置時能收集到的最大水果數量。

我們定義這個狀態轉移方程為：

$$
dp_B[i][j] = \max(dp_B[i-1][j-1], dp_B[i-1][j], dp_B[i-1][j+1]) + fruits[i][j]
$$

最後目標是找出 B 到達 (n−2,n−1) 的位置，也就是 `dp_B[n-2][n-1]`。

在迴圈中，我們需要注意到邊界條件：

- 初始狀態 `dp_B[0][n-1] = fruits[0][n-1]`。
- j 必須大於 i，因為 B 只能在對角線的右側走動。
- j 必須小於 n-1，不然會超出邊界。

接下來看到從左下角的 C，我們同樣可以用一個二維陣列 `dp_C` 來記錄 C 在每個位置能收集到的最大水果數量。

$$
dp_C[i][j] = \max(dp_C[i+1][j-1], dp_C[i][j-1], dp_C[i-1][j-1]) + fruits[i][j]
$$

而在 `dp_C` 我們的邊界條件為：

- 初始狀態 `dp_C[n-1][0] = fruits[n-1][0]`。
- `i > j` 且 `i > n - 1 - j`。
- i 必須小於 n-1，否則會超出邊界。

#### 改進策略：

其實目前的狀態只依賴於前一次的結果，所以可以將二維陣列壓縮為 prev 和 curr 兩個一維陣列，然後如果我們仔細觀察會發現其實 B 和 C 的路徑是對稱的，所以我們可以在跑完 B 的路徑後，將 matrix 沿著主對角線翻轉，重新跑一次剛才的 DP 就可以得到 C 的路徑，不用再寫一個新的迴圈。
