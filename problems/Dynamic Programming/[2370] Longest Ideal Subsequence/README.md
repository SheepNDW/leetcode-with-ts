## 2370. Longest Ideal Subsequence

解法 1：

令 `dp[i]` 表示以 `i` 為結尾的最長 subsequence 的長度。我們需要尋找這個 subsequence 的上一個位置 `j`，這樣就有 `dp[i] = dp[j] + 1`。
根據題意，`j` 所在的字母必須是與 `s[i]` 的 ASCII 差距在 k 以內的字母。知道是哪些字母後，我們要維護一個長度為 26 的陣列 `prev[ch]`，表示當前位置 `i` 之前最近的字母 `ch` 出現在哪個位置。

例如：目前 `s[i] = 'b'`，且 `k = 1`，那麼我們就要查看這兩個位置 `j1 = prev['a']` 和 `j2 = prev['c']`，這樣就可以有 `dp[i] = max(dp[j1], dp[j2]) + 1` 的關係式，要注意的是對於任意 `dp[i]` 都有一個基本解是 `dp[i] = 1`。

最後答案就是在所有 `dp[i]` 中最大的一個。

解法 2：

令 `dp[ch]` 表示已字母 `ch` 為結尾的最長子序列長度。那麼對於 `s[i]` 而言，假設其字母為 `'c'`，我們可以知道如果以 `s[i]` 為結尾的子序列，其倒數第二個字母的取值範圍 `[x:y]`，於是 `dp[c]` 就可以是更新為 `dp[x]` 到 `dp[y]` 中最大值加一。

