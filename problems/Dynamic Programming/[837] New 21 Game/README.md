## 837. New 21 Game

這題比較直覺的反應是從上而下去跑遞回，`f(x)` 表示從 `x` 點開始玩遊戲，最後達成目標（也就是停牌十點數小於等於 `n` 的機率）。我們可以從 `x` 得出下一步 `x+1, x+2, x+3, ... x+maxPts` 的機率，遞回式就會是：

```
f(x) = (f(x+1) + f(x+2) + f(x+3) + ... + f(x+maxPts)) / maxPts
```

終止條件是，當 `x >= k` 時停止遞回，在這個時候如果 `x <= n`，則回傳 `1`，否則回傳 `0`。

不過在本題中，遞迴的時間複雜度會是 `O(n * maxPts)`，會超時。

* 動態規劃 + sliding window

定義 `dp[i]`：當前分數為 i 時，最終能夠以 ≤ n 點停牌（即「贏」）的機率。

狀態轉移：

1. 對於 `i < k`：

   ```
   dp[i] = (dp[i+1] + dp[i+2] + ... + dp[i+maxPts]) / maxPts
   ```

   這裡的 `dp[i+j]` 代表從 `i` 點開始，下一步可能會到達的點。

2. 當 `i >= k` 時：

   - 如果 `i <= n`，則 `dp[i] = 1`（因為停牌點數小於等於 `n`，所以贏了）。
   - 如果 `i > n`，則 `dp[i] = 0`（因為停牌點數大於 `n`，所以輸了）。

此時我們需要維護一個 window sum，來記錄目前視窗內的總和，初始化 window 範圍為 `k` 到 `k + maxPts - 1`，這是我們所能達到的最大分數區間。

接下來我們每次都向左移動一個位置：

- `dp[i] = windowSum / maxPts`
- 然後更新 `windowSum`：

  - 減去 `dp[i + maxPts]`（因為這個點已經不在視窗內了）。
  - 加上 `dp[i]`（因為這個點現在進入了視窗）。
