## 3333. Find the Original Typed String II

想要找到長度至少爲 `k` 的結果，我們可以先計算任意長度的有效結果數，然後減去長度為 1, 2, ..., k-1 的結果數。

對於一個任意長度的結果，我們可以用乘法原理：如果一個字元在字串 `word` 中連續出現 `p` 次，那麼代表可以選擇輸入它 `1` 到 `p` 次，得出有 `p` 個可能的選擇，我們將所有 `p` 的可能性相乘，就能得到所有可能的結果數。

例如，如果 `word = abbcccaa`，則運行長度 `p` 為 `[1,2,3,2]`，結果總數為 `1×2×3×2=12`。

為了計算長度小於 `k` 的結果數，我們使用動態規劃來解決這個問題。

首先我們將所有 `p` 值記錄在一個 freq 陣列中，定義 `dp[i][j]` 為使用 freq 陣列的前 `i` 個群組，還原後總長度為 `j` 的結果數。

接下來，來思考狀態的轉移：

* 第 `i` 個群組（長度為 `freq[i-1]`），可對應 1 ~ `freq[i-1]` 的長度，每種都能去疊加前一層相同的狀態。
* `dp[i][j] += dp[i-1][j-x]`，其中 `x` 為第 `i` 個群組的長度，範圍為 `1` 到 `freq[i-1]` 且 `j-x >= 0`。

不過直接這樣做會超時，因此我們需要利用 prefix sum 來改進：

定義一個 `preSum[j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]`（到 j-1，不包含 j）
所以 `preSum[r] - preSum[l] = dp[i-1][l] + dp[i-1][l+1] + ... + dp[i-1][r-1]`。

最後我們把 `dp[freq.length][j]` for `j = 0 ~ k-1` 的值加總起來，得到長度小於 `k` 的結果數，回傳答案 `ans = (總數 - 長度小於 k 的結果數 + mod) % mod`。
