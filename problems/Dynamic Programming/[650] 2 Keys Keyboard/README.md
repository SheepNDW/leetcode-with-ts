## 650. 2 Keys Keyboard

從題意上傾向從 DP 著手。設計 `dp[n]` 為得到 `n` 個 A 的最小步數。

`dp[n]` 如何求呢？考慮到只有 copy 和 paste 兩個操作，必然要求在得到 n 個 A 之前，螢幕上必須是有 n/2 個 A，然後複製加貼上一次；或是有 n/3 個 A，然後複製加貼上兩次...依此類推，得到螢幕上有 n/j 個 A，然後複製加貼上 j - 1 次的表示式：

```
dp[n] = min(dp[n/j]+j) for j = 2,3,...n
```

如果用貪心策略可以最佳化上面的解。例如我們要得到 6 個 A，從 3 個 A 複製後貼上一輪要比從 2 個 A 複製貼上兩輪的方法更有效率，所以我們將 j 從小到大嘗試，只要遇到 i/j 整除，就不再考慮其他 j 的可能性。
