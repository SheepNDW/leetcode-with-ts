## 1015. Smallest Integer Divisible by K

給定一個正整數 K，請找出：由全部是數字 1 組成的正整數（repunit）中，最短且能被 K 整除的那一個，並回傳其位數長度。

這類數稱為 Repunit，例如：

* `1` -> 長度 1
* `11` -> 長度 2
* `111` -> 長度 3
* ...

若不存在這樣的正整數，請回傳 -1。

我們可以觀察到，當 K 含有因數 2 或 5 時，無論如何組成的 repunit 都不可能被 K 整除，因此這種情況下應直接回傳 -1。因為 repunit 的末位永遠是 1，也就是說恆為奇數，無法被 2 整除；同理，末位不可能是 0，無法被 5 整除。

接下來我們就要找出最小的 `n`，一個簡單的方式是從 `n = 1` 開始每次將 `n` 乘以 10 後加 1，直到 `n % K === 0` 為止。不過這樣的方式會產生非常大的數字，可能導致溢位。

為了避免溢位，我們可以利用餘數的性質來解決這個問題。

### 餘數性質

假設：
- $n_1 = k \cdot q + r_1$，其中 $r_1 = n_1 \mod k$

當我們計算下一個 repunit 時：
- $n_2 = 10 \cdot n_1 + 1 = 10(k \cdot q + r_1) + 1 = 10kq + 10r_1 + 1$

由於 $10kq$ 可以被 $k$ 整除，所以：
- $n_2 \mod k = (10r_1 + 1) \mod k = r_2$

以此類推：
- $r_3 = (10r_2 + 1) \mod k$
- $r_n = (10r_{n-1} + 1) \mod k$

這樣我們只需要追蹤餘數，而不需要儲存整個 repunit 數字，就能避免溢位問題。

### 為什麼一定會終止？

由於餘數 $r$ 的範圍是 $[0, k-1]$，最多只有 $k$ 種可能的餘數值。根據鴿巢原理（Pigeonhole Principle），如果在 $k$ 次迭代內沒有找到 $r = 0$，則必定會出現重複的餘數，形成循環。而我們已經排除了 $k$ 含有因數 2 或 5 的情況，所以在這些情況下，一定能在 $k$ 次迭代內找到答案。

### 複雜度分析

- **時間複雜度**：$O(k)$，最多迭代 $k$ 次
- **空間複雜度**：$O(1)$，只需要常數空間儲存餘數和長度
