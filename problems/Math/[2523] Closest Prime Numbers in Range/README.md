## 2523. Closest Prime Numbers in Range

給定一個範圍 `[left, right]`，請找出區間內最接近的兩個質數（即相鄰質數間距最小的那對）。如果區間內 沒有至少兩個質數，則回傳 `[-1, -1]`。

解題分為兩個部分：

1. 找出區間內所有的質數：
    - 透過埃拉托賽尼篩法（Sieve of Eratosthenes）找出區間內所有 `[2, right]` 的質數。
    - 找出位於 `[left, right]` 之間的質數。
2. 找出最小間距的質數對：
    - 掃過所有找出來的質數，找出相鄰質數間距最小的那對。

#### 判斷一個數是否為質數（Prime Number）

要判斷一個數字 `n` 是否為質數，通常有幾種方法：

1. 暴力法 $O(n)$

最直觀的方式就是遍歷所有 `2` 到 `n-1` 之間的數字，看是否有能整除 `n` 的數字。

```ts
function isPrime(n: number): boolean {
  if (n < 2) return false; // 大於 1 的自然數才可能是質數
  for (let i = 2; i < n; i++) {
      if (n % i === 0) return false;
  }
  return true;
}
```

2. 平方根法 $O(\sqrt{n})$

根據數學性質，如果 `n` 有一個因數 `x > sqrt(n)`，則 `n/x` 必然小於 `sqrt(n)`。因此我們只需要檢查 `2` 到 `sqrt(n)` 之間的數字即可。時間複雜度可以進一步降低為 $O(\sqrt{n})$。

我們可以觀察到：

* 2 是最小的質數，但所有 > 2 的偶數都不可能是質數，所以之後的偶數都不需要檢查。
* 3 也是質數，排除所有 > 3 的 3 的倍數。 
* 所以從 5 開始，每次增加 2，只需要檢查奇數。

```ts
function isPrime(n: number): boolean {
  if (n < 2) return false;
  if (n === 2 || n === 3) return true;
  if (n % 2 === 0 || n % 3 === 0) return false; // 排除 2 和 3 的倍數

  for (let i = 5; i * i <= n; i += 2) {
    if (n % i === 0) return false;
  }

  return true;
}
```


3. 埃拉托賽尼篩法（Sieve of Eratosthenes）

埃拉托賽尼篩法是一種用來找出區間內所有質數的方法。如果需要查詢大量的數字是否為質數，可以使用篩法先在 $O(n \log \log n)$ 的時間內預處理所有範圍內的質數。之後的查詢就只需要 $O(1)$ 的時間。

假設我們要找 `1 ~ 20` 之間的所有質數：

可以先建立一個布林陣列 `isPrime`，長度為 `n+1` (21)，初始值皆為 `true`，預設所有數字都是質數。

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   |

| 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| T   | T   | T   | T   | T   | T   | T   | T   | T   | T   |

首先直接將 `0` 和 `1` 設為 `false`，因為它們不是質數。

然後從 `2` 開始，將所有 `2` 的倍數設為 `false`，因為它們不是質數。

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| F   | F   | T   | T   | F   | T   | F   | T   | F   | T   | F   |

| 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| T   | F   | T   | F   | T   | F   | T   | F   | T   | F   |

接著找到下一個 `true` 的數字 `3`，將所有 `3` 的倍數設為 `false`。

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| F   | F   | T   | T   | F   | T   | F   | T   | F   | F   | F   |

| 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| T   | F   | T   | F   | F   | F   | T   | F   | T   | F   |

接下來下一個 `true` 的數字 `5`，但 `5` 的平方已經超過範圍了，所以不需要再檢查。

最終所有 `isPrime[i]` 為 `true` 的數字 `i` 都是質數。

```ts
function sieve(limit: number): boolean[] {
  const isPrime = new Array(limit + 1).fill(true);
  isPrime[0] = isPrime[1] = false;

  for (let i = 2; i * i <= limit; i++) {
    if (isPrime[i]) {
      for (let j = i * i; j <= limit; j += i) {
        isPrime[j] = false;
      }
    }
  }

  return isPrime;
}
```
