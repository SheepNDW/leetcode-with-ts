## 3013. Divide an Array Into Subarrays With Minimum Cost II

### 題目描述

給定一個整數陣列 `nums` 和兩個整數 `k` 和 `dist`。

需要將陣列分成 `k` 個**非空**的子陣列，使得：
- 第一個元素 `nums[0]` 必須在第一個子陣列中
- 對於每個子陣列（除了第一個），其第一個元素必須在前一個子陣列最後一個元素的索引範圍 `[1, dist]` 內

**成本**定義為每個子陣列第一個元素的總和。

回傳所有可能劃分方式中的**最小成本**。

本質就是從 `nums[1]` 開始，尋找一個長度為 `dist+1` 的滑窗，使得裡面 top k smallest 的元素和最小。

### 解題思路

這題的關鍵在於：
1. 第一個子陣列必須從 `nums[0]` 開始，所以 `nums[0]` 一定會被計入成本
2. 剩下需要選擇 `k-1` 個元素作為子陣列的起始點
3. 每次選擇下一個起始點時，必須在當前起始點後的 `[1, dist]` 範圍內

**核心觀察：** 這是一個**sliding window + 維護最小 k-1 個元素**的問題。

### 步驟

1. **初始化兩個資料結構：**
   - `smallSet`：最大堆，維護窗口內最小的 `k-1` 個元素
   - `largeSet`：最小堆，維護窗口內其餘的元素

2. **sliding window處理：**
   - 窗口大小為 `dist + 1`
   - 對於每個位置 `i`，將 `nums[i]` 加入窗口
   - 當窗口形成後（`i >= dist + 1`），移除窗口外的元素 `nums[i - dist]`

3. **維護最小 k-1 個元素：**
   - 新元素加入時，若 `smallSet` 未滿，直接加入
   - 否則，比較新元素與 `smallSet` 的最大值，決定放入哪個集合
   - 移除元素時，需要重新平衡兩個集合

4. **計算結果：**
   - 維護 `smallSet` 中所有元素的和 `sum`
   - 每次窗口形成後，更新最小成本 `res = Math.min(res, sum)`
   - 最終 return `res + nums[0]`

### LazyMultiSet 實作

由於需要頻繁的插入、刪除和查詢最值操作，使用**延遲刪除**技巧：
- 刪除時只在 `map` 中標記，不立即從優先佇列中移除
- 存取堆頂時，清理已被標記刪除的元素
- 維護 `_size` 變數來快速獲取實際大小（避免 O(n) 遍歷）

**優點：**
- 插入：O(log n)
- 刪除：O(1)（延遲）
- 查詢最值：O(log n)（均攤）

### 複雜度分析

- **時間複雜度：** O(n log k)
  - 外層迴圈 O(n)
  - 每次插入/刪除操作 O(log k)
  - 延遲刪除的清理操作均攤 O(log k)

- **空間複雜度：** O(k)
  - 兩個優先佇列最多儲存 O(dist) 個元素
  - Map 存儲計數信息

### 關鍵要點

1. **延遲刪除機制：** 避免在優先佇列中直接刪除元素，只在存取時清理
2. **維護 size 變數：** O(1) 取得實際大小，避免每次遍歷 map
3. **兩個堆的平衡：** 確保 `smallSet` 始終維護最小的 `k-1` 個元素
4. **sliding window邊界：** `i >= dist + 1` 時才開始計算結果並移除舊元素

### 程式碼結構

```
LazyMultiSet (封裝延遲刪除的多重集合)
├── insert()  - O(log n)
├── remove()  - O(1)
├── top()     - O(log n) 均攤
├── pop()     - O(log n) 均攤
└── size()    - O(1)

minimumCost (主邏輯)
├── 初始化兩個 LazyMultiSet
├── sliding window遍歷
│   ├── 加入新元素
│   ├── 維護最小 k-1 個元素
│   └── 移除舊元素並重新平衡
└── 回傳最小成本
```
