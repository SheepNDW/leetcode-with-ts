## 287. Find the Duplicate Number

* `indexing sort`

利用 indexing sort (cycle sort)，嘗試將 `n+1` 個元素盡可能按照 "index == value" 的方式重新放在 1 ~ n+1 的位置上，都放完後從頭掃過，當 `nums[index] !== index` 的就是我們要找的答案。

註：在排序的過程可以將陣列頭插入一個 0 調整索引順序方便操作

* 快慢指針

將 `1 ~ n` 個數放在 `n+1` 個位置上，那麼 val -> index 將會出現一個一對多的映射，反之，index -> val 將會有一個多對一的映射，而其餘的都是一一映射。於是這些 index 和 val 勢必會有一部分形成一個環。


例如：`[1, 4, 3, 5, 6, 1, 2]` 從 index 到 val 的映射關係是：

| index | val |
| ----- | --- |
| 0     | 1   |
| 1     | 4   |
| 2     | 3   |
| 3     | 5   |
| 4     | 6   |
| 5     | 1   |
| 6     | 2   |

我們可以藉由想成一個隱性的 linked list 來建立一個有向圖，而這個圖必定會有一個環：

```
                  [4 0x6] -> [6 0x2]
                  ／               ＼
[0 0x1] -> [1 0x4]                 [2 0x3] 
                  ＼               ／
                  [5 0x1] <- [3 0x5]
```

這個環的起點就是重複的數字。

可以用快慢指針的方式找到這個環，快指針每次走兩步，慢指針每次走一步，當兩者相遇時，將快指針重置到起點，然後兩者同時走一步，當再次相遇時就是環的起點。

整個過程如下：

| slow (init: `nums[0] = 1`) | fast (init: `nums[0] = 1`) | step |
| -------------------------- | -------------------------- | ---- |
| slow = `nums[1]` = 4       | fast = `nums[nums[1]]` = 6 | 1    |
| slow = `nums[4]` = 6       | fast = `nums[nums[6]]` = 3 | 2    |
| slow = `nums[6]` = 2       | fast = `nums[nums[2]]` = 1 | 3    |
| slow = `nums[2]` = 3       | fast = `nums[nums[1]]` = 6 | 4    |
| slow = `nums[3]` = 5       | fast = `nums[nums[6]]` = 3 | 5    |
| slow = `nums[5]` = 1       | fast = `nums[nums[2]]` = 1 | 6    |

兩個指針在 `nums[5]` 相遇，此時將快指針重置到起點，兩者同時走一步：

| slow (`nums[5] = 1`) | fast (`nums[0]`) | step |
| -------------------- | ---------------- | ---- |
| slow = `nums[1]`     | fast = `nums[1]` | 1    |

兩者在 `nums[1]` 再次相遇，此時就是環的起點，也就是重複的數字所指向的位置。
