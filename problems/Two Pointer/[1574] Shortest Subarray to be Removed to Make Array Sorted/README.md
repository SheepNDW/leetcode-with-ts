## 1574. Shortest Subarray to be Removed to Make Array Sorted

探索 subarray 題目時，追根究底就是要確定他的兩個邊界。我們可以把陣列分成三段 `[0,i]`、`[i+1,j-1]`、`[j,n-1]`，中間那段就是我們嘗試要刪除的 subarray，為此需要滿足三個條件：`[0:i]` 必須是單調遞增，`[j:n-1]`也是單調遞增的，並且 `arr[i] <= arr[j]`。

第一個條件比較好判斷，只要從左往右掃過去，一旦發現 `arr[i] < arr[i-1]` 時就可以終止搜尋。條件三也很好實作，就是從後往前遍歷，找到最前面的一個 `j` 滿足 `[j:n-1]` 是單調遞增的。

條件二怎麼辦呢？如果此時 `arr[i] > arr[j]` 怎麼辦呢？因為 `[j:n-1]` 是遞增的，所以我們可以讓 `j` 向右移動，直到 `arr[i] <= arr[j]` 為止。這樣就找到了一組 `[i,j]` 成為一個潛在的 subarray。

接下來我們就是繼續移動 `i`，又 `i` 的移動也必須保證 `[0:i]` 是遞增的，所以 `arr[i]` 會變大，`arr[j]` 也要增大來保持 `arr[i] <= arr[j]`，不斷地重複這個尋找的過程，直到 `i` 到達 `j` 的前一個位置或是 `i` 已經無法形成遞增的 subarray 為止。

最後只要從所有可能的 subarray 中找出最短的即可。
