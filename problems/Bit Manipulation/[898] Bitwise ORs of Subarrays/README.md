## 898. Bitwise ORs of Subarrays

本題的突破口在於，OR 的結果不會特別多。任何一個元素作為左端點的時候，隨著右端點的移動，OR 的結果只會是單調地變大（某個 bit 的 0 變成 1），因此最多隻有 32 種可能。同理，以任何一個元素可以作為右端點，那麼所有 subarray 的 OR 結果做多也是 32 種。

因此我們可以用類似背包問題的演算法，窮舉上一個元素為右端點時所有 subarray 的 OR 值，來更新該元素為右端點時所有 subarray 的 OR 值。

1. 用一個集合 `cur` 紀錄「目前這個數字作為右端點時，所有可能的子陣列 OR 結果」。
2. 新的一個數字 `num`，只要做兩件事：
   - `cur` 裡的每個舊結果都再與 `num` OR，產生新結果。
   - 自己本身單獨做為一個子陣列 `[num]` 也加入。
3. 最後統一把所有 OR 結果存在一個大集合 `all`，回傳 `all.size`。
