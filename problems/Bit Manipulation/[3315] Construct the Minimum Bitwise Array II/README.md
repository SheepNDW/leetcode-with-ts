## 3315. Construct the Minimum Bitwise Array II

對於每一個 `nums[i]`，找出一個最小的整數 `x`，使得 `x | (x+1) == nums[i]`，並將 `x` 放入結果陣列中。

### 解題思路

我們可以先觀察一下 `x+1` 的二進位表示法。當我們將 `x` 加 1 時，會從最低位元開始進行進位操作，直到遇到第一個 0 為止，這個 0 會變成 1，而之前的所有 1 都會變成 0。所以 `x | (x+1)` 的結果會將 `x` 中最低位元的 0 變成 1。

用圖來看就是：

```
... [高位不重要] 0 111...111
               ^  ^^^^^^^^
               |    t 個尾端 1
            這個 0 是「最右邊的 0」
```

我們令 `t` 為 `x` 尾端連續 1 的個數，那麼 `x + 1` 就會是：

* 把 `x` 中最右邊的 0 變成 1
* 把 `x` 中尾端的 `t` 個 1 全部變成 0

接著可以導出：

* `x` 的低 `t` 位元都是 1
* `x+1` 在第 `t` 位元是 1
* 兩者做 OR 後，低 `t+1` 位元都會變成 1

也就是 `x | (x+1)` 的結果必然是「低位一段連續 1」的結構。

接著令 `n = nums[i]`，我們接著分析兩個情況：

1. **`n` 為偶數**

此時 `n` 的最低位元是 0，代表一定無解，因為 `x | (x+1)` 的結果最低位元必然是 1。此時答案就放上 -1。

1. **`n` 為奇數**

如果 `n` 是奇數，代表 `n` 的二進位尾端一定有一段連續的 1，例如：`13 = 1101`，尾端有連續 1 個 `1`、`7 = 111`，尾端有連續 3 個 `1`。

另 `k` 為 `n` 裡面尾端連續 1 的個數，那所有可行的 `x` 就會是從尾端裡的 `k` 個 1 中挑一個位置變成 0，其他位元保持不變。就會滿足 `x | (x+1) == n`。

然後題目要找的是「最小的 x」，所以我們把那段尾端的 1 裡面最高位的 1 變成 0，那麼答案就會是：

```
ans = n 把尾端的 k 個 1 中最高位的 1 變成 0
```

用一個例子來驗證一下：

`n = 7 (111)`，尾端有 3 個 1，最小的 `x` 就是把最高位的 1 變成 0，變成 `011`，也就是 `3`。

然後 `3(011) | 4(100) == 7`，符合條件。

### 實作細節

```ts
for (const n of nums) {
  let x = -1;
  let d = 1;

  while ((n & d) !== 0) {
    x = n - d;
    d <<= 1;
  }

  res.push(x);
}
```

我們可以另一個 `d` 為目前檢查的位元，初始為 `1`（也就是最低位元）。然後開始比對 `n & d`：

* 如果 `n & d` 不等於 `0`，代表目前位元是 `1`，我們就把 `x` 設成 `n - d`（也就是把目前位元的 1 變成 0），然後把 `d` 左移一位，繼續檢查下一個位元。
* 如果 `n & d` 等於 `0`，代表「在 n 的尾端連續 1 掃描結束了」（遇到第一個 0）。

最後把 `x` 放入結果陣列中。如果 `n` 是偶數，`x` 會保持初始值 `-1`
