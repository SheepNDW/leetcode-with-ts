## 260. Single Number III

這是經典題，首先把所有數字 XOR 起來，假設最後的答案是 x 和 y，那將會得到 `x^y`，這有什麼用呢？

x、y 不相等 ，也就是說 `x^y` 不可能為零，必然有一個 bit 位置上 x 和 y 不相同。那麼我們就可以把所有數字按照這個位置的 bit 值分成兩組，其中一組與 x 相同，另一組與 y 相同，把兩組數字各自做 XOR 操作，兩兩相同的都會被消掉，最後各自留下的就是我們要找的 x 和 y 本身。

e.g. [1, 2, 1, 3, 2, 5]

3, 5 的 XOR 如下：

```
3 ^ 5:

0 0 1 1
0 1 0 1
-------
0 1 1 0
```

要找到 `3 ^ 5` 的不同 bit 位置，最直觀的方式就是從右邊開始找，找到第一個不同的位置：

```
diff = 1 // 0001
xor = 6  // 0110

檢查 xor & diff 是否為 0，如果是，則 diff 左移一位，直到找到不同的 bit 位置

0 1 1 0
0 0 0 1
-------
0 0 0 0

diff << 1 // 0010

0 1 1 0
0 0 1 0
-------
0 0 1 0
```

這樣我們可以找到在第二個 bit 位置上 x 和 y 不同，接著我們就可以把所有數字按照這個位置的 bit 值分成兩組

另一個比較巧妙的方法是利用幾個 bit 操作技巧：

1. `x & (x - 1)`：表示取消（unset）最右邊的已設位（set bit）

當我們從 `x` 中減去 1 時，所有從最右邊開始的連續 0 都會變成 1，而最右邊的 1 會變成 0。然後，將結果與原始數值 `x` 進行位元AND運算，這會將 `x` 中最右邊的已設位取消。

2. `x ^ (x & (x - 1))`：表示只保留最右邊的 set bit

首先 `x & (x - 1)` 取消了 `x` 中最右邊的 set bit，然後將結果與原始數值 `x` 進行 XOR 運算，這樣就只保留了最右邊的 set bit。

3. `log2(x ^ (x & (x - 1)))`：表示找到最右邊的 set bit 的位置

`log2` 函數計算該數值的二進位對數，從而確定最右邊的 set bit 的位置。

例如 `log2(0100) = 2`，因為 `0100` 表示 2 的平方。

所以最右邊的 set bit 的位置就是 2（從 0 開始計算）。
