## 2560. House Robber IV

經典的 House Robber 問題中，目標是從一排房屋中偷取最大的金錢，但是不能偷相鄰的房屋，迫使搶匪進入一個分支決策的過程，在每個房子中必須選擇搶或是跳過。如果搶了，他必須將其價值加上前兩間房子搶走的最大價值，如果跳過，則價值等於前一間房子搶走的最大價值。這導出了一個遞迴關係：

```ts
maxAmount(i) = max(maxAmount(i - 2) + nums[i], maxAmount(i - 1))
```

而在本題中，搶匪仍需要遵守不能連續搶兩間相鄰的房子的限制。然而，這一次他不是想要最大化搶走的金錢，而是想要最小化從任何一個房子被盜的最大金額，同時確保至少有 `k` 個房子被搶。

我們不需要專注於最大化總金額，而是要確保在搶劫至少 `k` 間房子的情況下，從任何一間被搶的房子中偷走的最大金額最小。我們可以用 binary search 來找到這個最小值。初始的最大獎勵的最小值為 `left = min(nums)`，最大獎勵的最大值為 `right = max(nums)`。

我們每次猜一個最小的可能 `cap`，然後檢查是否可以搶劫至少 `k` 間房子，同時確保沒有任何一間房子的價值超過 `cap`。如果可以，就修正 `right = cap`，否則修正 `left = cap + 1`。最後返回 `left` 即為答案。

至於要怎麼確認是否可以搶劫至少 `k` 間房子，我們可以使用 Greedy 的方法，從左到右遍歷房子，遇到 `<= cap` 的房子就搶，並跳過下一間房子。如果搶了 `k` 間房子，就返回 `true`，否則返回 `false`。
