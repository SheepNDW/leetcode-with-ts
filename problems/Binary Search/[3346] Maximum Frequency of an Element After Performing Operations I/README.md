## 3346. Maximum Frequency of an Element After Performing Operations I

題目要求我們必須執行 `numOperations` 次操作。  
不過，由於可以選擇若干個元素加上 `0`，且 `numOperations ≤ nums.length`，  
因此可以將問題等價轉化為：

> 我們 **最多可以選擇 `numOperations` 個元素進行調整**，  
> 每個元素的調整幅度落在區間 `[−k, k]` 之內。

我們希望讓某個數字在最終陣列中出現的次數（頻率）最大。  
也就是說，我們要找出一個「目標值」 `i`，  
並計算最多有多少個元素可以被調整成這個目標值。  
令此數量為 `f(i)`，那麼整體答案即為：

$$
\text{ans} = \max_i f(i)
$$

### 計算 \( f(i) \)

對於每個目標值 `i`，  
能被調整成 `i` 的元素必須滿足：

$$
\text{nums}[t] \in [i - k, i + k]
$$

因此可以透過 **二分搜尋法** 找出落在此範圍內的元素個數：

- `l = lowerBound(nums, i - k)`：第一個大於等於 `i - k` 的位置  
- `r = upperBound(nums, i + k) - 1`：最後一個小於等於 `i + k` 的位置  

區間 `[l, r]` 的長度代表可被調整成 `i` 的潛在元素數：

$$
\text{cover}(i) = r - l + 1
$$

### 加上操作次數限制

由於我們最多只能操作 `numOperations` 次，  
所以實際上能被轉換的最大數量為：

$$
f(i) = \min(\text{cover}(i),\ \text{numOperations})
$$

### 考慮原本就等於 `i` 的元素

如果 `i` 已存在於 `nums` 中，那些元素不需要操作即可計入結果。  
設其出現次數為 `count(i)`，  
則最終公式為：

$$
f(i) = \min(\text{cover}(i),\ \text{numOperations} + \text{count}(i))
$$

---

## 3347. Maximum Frequency of an Element After Performing Operations II

在 3347 題中，`k` 與 `nums[i]` 的範圍被擴大到 $10^9$，  
因此若仍枚舉 `[min(nums), max(nums)]` 區間內的所有整數，  
將導致時間複雜度過高。

### 觀察公式

由於：

- `numOperations` 為常數；  
- 若 `i` 不存在於 `nums`，則 `count(i) = 0`；

因此可以發現：

$$
f(i) \text{ 的值僅取決於 } (l, r)
$$

換句話說，`f(i)` 的結果完全取決於哪些元素被包含在範圍 `[i - k, i + k]` 之內。

### 關鍵觀察：邊界變化才影響結果

若多個 `i` 擁有相同的 `(l, r)`，則它們的 `f(i)` 也相同。  
因此我們只需要在「邊界變化」時重新計算一次答案。

### 右邊界的變化

令 `r_i` 為排序後陣列中最後一個小於等於 `i + k` 的索引。  

假設：

$$
i + k = \text{nums}[r_i]
$$

那麼下一個臨界點是：

$$
j + k = \text{nums}[r_i + 1]
$$

對於所有 $i < x < j$，  
其右邊界仍為相同的 `r_i`。  
同樣地，左邊界 `l` 也僅在跨越元素時才改變。

### Sliding Window

可將 `(l, r)` 想像成一個以 `i` 為中心的滑動視窗：

- 當 `i` 增加時，右邊界 `i + k` 向右滑動；  
- 每當它跨過一個新元素時，`r` 才會變化；  
- 同理，左邊界 `i - k` 向右滑動時，`l` 才會變化。

因此只有在「左或右邊界變動」時，`f(i)` 才需要重新計算。

### 最佳化策略

綜合上述觀察，只要針對每個元素 `num`，  
列舉以下三個候選目標值即可涵蓋所有臨界變化點：

- `num`：該元素本身  
- `num - k`：左邊界發生變化的臨界點  
- `num + k`：右邊界發生變化的臨界點  

這樣就能避免從 `min` 到 `max` 的暴力枚舉，  
並將時間複雜度降至 **O(n log n)**。

---

### 結論

| 題目     | 方法                           | 複雜度     | 枚舉策略           |
| -------- | ------------------------------ | ---------- | ------------------ |
| **3346** | 暴力枚舉 `[min, max]`          | O(R log n) | 枚舉所有可能目標值 |
| **3347** | 邊界枚舉 `{num, num−k, num+k}` | O(n log n) | 只在邊界變化時計算 |

兩題的核心公式相同：

$$
f(i) = \min(r - l + 1,\ \text{numOperations} + \text{count}(i))
$$

差別僅在於 **「如何枚舉目標值」**。
