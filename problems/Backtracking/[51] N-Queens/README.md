## 51. N-Queens

經典的八皇后問題，考驗 DFS 和回溯法。

在 n×n 的棋盤上放置 n 個皇后，使得它們互不攻擊（任意兩個皇后不能處於同一列、同一欄或同一對角線上）。返回所有可能的解決方案。

### 解題思路 - 回溯法（Backtracking）

這題使用回溯法的經典應用。核心思想是：

1. **逐列放置**：從第 0 列開始，逐列嘗試放置皇后
2. **驗證合法性**：每次放置前檢查當前位置是否安全
3. **遞迴探索**：放置成功後繼續下一列
4. **回溯**：如果某一列無法放置，則回溯到上一列，嘗試其他位置

### 關鍵點

#### 1. 棋盤表示
使用二維陣列 `board`，初始化為全 `'.'`，放置皇后時標記為 `'Q'`

#### 2. 有效性檢查 `isValid(row, col)`
需要檢查四個方向：
- **同一欄**：檢查 `col` 欄的所有已放置的列（0 到 row-1）
- **同一列**：檢查 `row` 列的所有已放置的欄（0 到 col-1）
- **左上對角線**：檢查 `(row-k, col-k)` 方向
- **右上對角線**：檢查 `(row-k, col+k)` 方向

**注意**：由於我們是逐列放置，所以：
- 同一列的檢查其實是多餘的（當前列還沒放過皇后）
- 下方對角線不需要檢查（還沒放置）
- 只需檢查上方的欄和兩條上方對角線

#### 3. DFS 流程
```
dfs(row):
  if row == n:
    找到一組解，加入結果
    return
  
  for col in 0..n-1:
    if isValid(row, col):
      放置皇后 board[row][col] = 'Q'
      dfs(row + 1)
      移除皇后 board[row][col] = '.'  // 回溯
```

💡 **說明**：這裡的 `row` 代表當前要處理的列（第幾列），`col` 代表在該列的哪一欄放置皇后
