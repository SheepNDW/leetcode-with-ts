## 3459. Length of Longest V-Shaped Diagonal Segment

仔細拆解後會發現，題目要求的 V 形狀其實就是兩條斜線段的組合，每個格子、每個方向都只會進入一次，我們可以直接用 DFS 去把所有的狀態都跑過一遍。

定義一個 `dfs(x,y,d,t)` 函式，表示以 `d` 方向進入 `(x,y)` 格子同時還剩下 `t` 次轉彎機會時的最大長度。如果 `t == 0`，那就只能繼續按照 `d` 方向進入下一格 `(x1,y1)`，否則就可以再多考察 `d+1` 的方向進入下一個格子 `(x2,y2)`。

同時在進入每個格子前都要先檢查邊界條件以及是否滿足數值上的約束，否則直接停止往下走。

最後記憶化要根據 `(x,y,d,t)` 四個參數來做，但是在 JS/TS 環境下，開一個 4D 陣列會比較麻煩，可以把 d 和 t 給合併成一個參數 `dt = d * 2 + t`，這樣就只需要開一個 3D 陣列 `dp[x][y][dt]` 就可以了。

* 扁平化的原理

原本需要用一個二維陣列表示 d 和 t 的狀態：

`memo[4][2]`: 四個方向、轉彎剩餘次數(0,1)

會發現到其實一共就只有 8 種狀態，所以可以把它們扁平化成一個一維陣列：

`memo[8]`: 每個方向兩種 t，所以 `dt = d * 2 + t`

他們之間的對應關係如下：

```
d=0,t=0 → dt=0
d=0,t=1 → dt=1
d=1,t=0 → dt=2
d=1,t=1 → dt=3
d=2,t=0 → dt=4
d=2,t=1 → dt=5
d=3,t=0 → dt=6
d=3,t=1 → dt=7
```
