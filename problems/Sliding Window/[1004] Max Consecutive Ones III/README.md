## 1004. Max Consecutive Ones III

對於求 subarray 問題，通常的做法就是固定左邊界，然後向右探索右邊界。假設左邊界為 `j`，那麼要讓右邊界 `i` 盡可能遠，使得 `[j,i]` 有最多 `k` 個 `0`，接下來只要讓 `j` 單調右移同時中間遇到幾個 `0` 即可。

用一個 for 迴圈遍歷左邊界 `j`，對於每個 `j` 我們追蹤向右移動的 `i`，將 `i` 停在最遠且有 `k` 個 `0` 的點上，然後將 `j` 往右如果這個 `nums[j]` 是 `0` 的話就需要歸還一個 flip 的名額，並調整目前最長的距離，再接著移動 `i`。

假設：`nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2`，那麼我們可以得到以下的過程：

```
k = 2, max = 1
[1,1,1,0,0,0,1,1,1,1,0]
 j
 i

k = 1, max = 4
[1,1,1,0,0,0,1,1,1,1,0]
 j
       i

k = 0, max = 5
[1,1,1,0,0,0,1,1,1,1,0]
 j
         i

k = 0, max = 2
[1,1,1,0,0,0,1,1,1,1,0]
         j
           i

k = 0, max = 6
[1,1,1,0,0,0,1,1,1,1,0]
         j
                   i
```
