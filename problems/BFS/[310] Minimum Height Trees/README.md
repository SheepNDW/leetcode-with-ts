## 310. Minimum Height Trees

這題本質上是 BFS，或是樹的 level order。

題目想要在一群 nodes 裡找出一個 node 當作 root，使得從這個根節點出發發散到葉子節點的路徑範圍最短。由此可知這個根節點必須盡可能接近“中央”。如何確定“中央”的位置呢？我們可以反過來從“邊疆”往內收縮。從所有葉子節點（入度為 1、出度為 0）同步出發，一步一步往前走，最終會合點就是最“中央”的地方。

這就是一棵樹的層序走訪 (level order tranversal)。傳統的樹操作都是從 root 開始的（因為通常只給你一個 root），必須從頂往底用佇列的結構一層一層遍歷。但這裡給出了圖的表述，這樣我們就可以輕易地找出哪些是最底端的葉子節點，從葉子節點反推上去。

具體的做法很像拓撲排序，可以參見 269. Alien Dictionary。我們要借助一個 hash 記錄所有節點的度，每次我們將度為 1（說明是葉子節點或邊緣節點）加入佇列，佇列每彈出一個元素，我們就找這個元素的相鄰節點，將它們的度都減一，一旦減至１（說明這個節點被砍成了邊緣節點），就可以把這個節點加入佇列。

直到什麼時候停止呢？直到所有已彈出的元素數目，加上已經加入佇列的元素數目，恰好等於ｎ為止。這時候，佇列的元素數目，要麼為１，要麼為２，這一個或兩個元素就是答案。
