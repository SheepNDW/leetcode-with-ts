## 838. Push Dominoes

根據題意，我們按照回合的順序進行 BFS 模擬，佇列的初始狀態我們放入所有被推倒的骨牌。

每個回合中，我們彈出所有在上一回合被推倒的骨牌，如果是個剛被往左推倒的骨牌，會在此回合影響它左邊的骨牌（如果未被推倒），使其有左傾的趨勢；同理，對於剛被往右推倒的骨牌，會影響它右邊的骨牌（如果未被推倒），使其有右傾的趨勢。要注意的是，有些骨牌可能會在此回合既被左推倒又被右推倒，那麼它的最終狀態就會是站立 `"."`。

每一回合結束時，我們要將所有在本回合被推倒的骨牌加入佇列，最終所有的骨牌會在過程中被加入到佇列確認狀態。

對於每一回合，處理流程如下：

1. 彈出目前佇列中的所有骨牌，代表這些骨牌在此回合會試圖推倒鄰近的直立骨牌。
2. 對於每張骨牌：
   - 如果是向左倒（L），就影響左邊那張骨牌（若尚未被推倒）
   - 如果是向右倒（R），就影響右邊那張骨牌（若尚未被推倒）
3. 對於每個被影響的骨牌，我們使用一個暫存的 `Map` 來紀錄它收到的推力（+1 表 R，-1 表 L，0 表左右同時推）
4. 回合結束後，對這些被推的骨牌根據推力總和更新狀態：
   - 若推力總和為 +1 → 向右倒，加入佇列
   - 若推力總和為 -1 → 向左倒，加入佇列
   - 若推力總和為 0 → 左右同時推，保持直立，不加入佇列


重點邏輯：
- 所有骨牌是同時發生推動，因此「不能立刻更新狀態」，必須等同一層都處理完後，再統一決定哪些骨牌會倒下。
- 使用 `Map` 暫存下一輪的推力是為了避免「左右同時推」的時序錯誤。
- 每張骨牌最多只會被推倒一次，時間複雜度為 O(n)。
