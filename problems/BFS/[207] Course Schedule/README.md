## 207. Course Schedule

我們將依賴關係描述成一條有向邊，課程 a 需要先修課程 b，那麼就有一條邊從 a 指向 b。本題的本質就是在一個有向圖中判斷是否存在環。如果有環，就代表有循環依賴，無法完成所有課程。

在圖論中，判斷有向圖是否有環，一般有 DFS 和 BFS 兩種方法：

#### 解法 1: DFS

DFS 的基本思路是，從任意一個未走訪過的節點開始做 DFS 遍歷，如果在某條支路的遍歷過程中（還沒遍歷到出度為 0 的節點），遇到了這條支路上已經走訪過的節點，就代表有環。

需要注意的是，“遇到了任何在這條支路上已經走訪過的節點”和“遇到了任何已經走訪過的節點”是不同的概念，例如：

```
1 -> 2 -> 3 -> 4
          ^    
5 -> 6 -> 7 -> 8
          ^____|
```

我們從 1 開始依次走訪 1 -> 2 -> 3 -> 4，然後遍歷結束。再從 5 開始依次走訪 5 -> 6 -> 7，這時 3 已經走訪過了，但是這不會誤判為有環。因為 3 不是在目前未完成的支路上走訪過的，再接著看 5 -> 6 -> 7 -> 8 -> 7，這時 7 已經被這條支路走訪過，並且這條支路並沒有走到底，所以這時就可以判斷有環。

所以我們要標記兩種 `visited[i]`，如果節點 `i` 已經在其他遍歷到底的支路上走訪過，就標記為 1；如果節點 `i` 是在目前未完成的支路上走訪過的，就標記為 2。只有在遍歷過程中遇到了標記為 2 的節點，才代表有環。那麼是什麼時候標記 1 什麼時候標記 2 呢？方法是：在某條 DFS 路徑上，第一次遇到的節點 `i` 的時候標記為 2，在回溯返回到 `i` 的時候標記為 1（因為能夠成功返回，代表這條支路上沒有環，都是死路，此後任何入度指向為 `i` 的節點都不會形成環）。

核心程式碼很簡單：

```ts
function dfs(cur: number): boolean {
  if (visited[cur] === 1) return true;
  if (visited[cur] === 2) return false;
  visited[cur] = 2;
  for (const next of graph[cur]) {
    if (dfs(next) === false) return false;
  }
  visited[cur] = 1;
  return true;
}
```

#### 解法 2: BFS

BFS 的演算法思想是拓撲排序。從外圍往核心進發，每次在圖中找到入度為 0 的節點，將其刪除，直到圖中沒有入度為 0 的節點。如果最後圖中還有節點，就代表有環。
