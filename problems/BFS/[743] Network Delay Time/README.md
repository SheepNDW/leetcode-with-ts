## 743. Network Delay Time

題目給了一個加權有向圖，圖中有 `N` 個節點，編號從 `1` 到 `N`。每個邊的資訊以三元組 `(u, v, w)` 的形式給出，表示從節點 `u` 到節點 `v` 有一條權重為 `w` 的邊。題目還給了一個起始節點 `K`，要求我們計算從節點 `K` 出發，傳送訊息到所有其他節點所需的最短時間。如果有任何節點無法從 `K` 傳送到，則回傳 `-1`。

### Dijkstra (BFS + PQ)

對於 BFS，每次擴展對應的只是「幾何意義上的」層級自增 1，只適合用在尋找最小步數。如果每一步有權重（也就是邊有權值），然後要求起點到終點最短權重和的問題，就不太適合用傳統的 BFS 了。

Dijkstra 演算法是一種適用於加權圖且邊權重為非負的最短路徑演算法。本質上就是將 BFS 的傳統佇列換成優先佇列 (Priority Queue)，採用貪心策略，每次擴展當前距離起點最近的節點 `cur`，然後將它所有鄰接的節點以 `[next, dist]` 的形式放入優先佇列中，`dist` 是從起點到 `cur` 的距離再加上 `cur` 到 `next` 的邊權重。而貪心的理由在於，當我們從優先佇列中取出 `cur` 時，已經確定了從起點到 `cur` 的最短距離，因為如果有更短的路徑，`cur` 就會在更早之前被取出。

這種方式的時間複雜度是

* 標準寫法（有 `dist[]`）：`O((E + V) log V)`
* lazy 寫法（只用 visited）：最差 `O(E log E)`

### Floyd

求兩點之間的最短路徑也可以使用 Floyd-Warshall 演算法，程式碼短且易懂，而且可處理負權邊（但若有負權環則最短路徑不存在）。本質上就是掃遍所有的節點 k 看是否能對 i 到 j 的距離有所改善。時間複雜度是 `O(N^3)`，適合節點數量不大的情況。

實作上用一個二為陣列 `dp` 來存放 i 到 j 的最短距離，初始時 `dp[i][j]` 設為無限大，然後將邊的權重資訊填入 `dp` 陣列中並將 `dp[i][i]` 設為 0。接著掃遍所有的 k，對每一對 (i, j) 更新 `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])`。最後檢查從 K 出發到所有節點的距離，取最大值，如果有無限大的距離則回傳 -1。
