## 3440. Reschedule Meetings for Maximum Free Time II

假設要移動的會議為 `i`，我們有兩種最佳移動方式：

1. 如果會議 `i` 能被移到某個空檔，且這個空檔並非會議 `i` 的左右鄰接空檔（即 `i` 的新時段不會與原本左右兩側的空閒區段重疊），那麼移動後就會有一個新的空閒區段，長度為會議 `i` 的長度加上原本的空閒區段長度。
2. 否則，移動會議 `i` 僅是讓它的左右鄰接空閒區段合併成一個更長的空閒區段。

可以發現到，重新排程會議後，所能獲得的最大空閒時間，就是所有這類新產生的空閒時間中的最大值。而為了知道 `i` 能不能符合第一種情況，我們用一個 `q[i]` 來標記。
先從左到右掃過所有會議，維護目前為止所有非相鄰於 `i` 的空閒區段的最大長度 `t1`。如果 `t1 >= endTime[i] - startTime[i]`，則說明會議 `i` 左邊存在可用於第一種情境的空閒區段，我們記錄 `q[i] = true`。同理，再從右到左掃過所有會議，檢查會議 `i` 的右側是否也存在滿足條件的空閒區段。

接著對於所有會議 `i`，假設 left 為前一場會議結束時間，right 為下一場會議開始時間，根據 `q[i]` 的值，我們可以根據兩種情境得出兩個情境：

1. 如果 `q[i] == true`，那新的空閒區段長度為 `right - left`。
2. 反之，新的空閒區段長度為 `right - left - (endTime[i] - startTime[i])`。

最後回傳所有新的空閒區段長度中的最大值即可。
