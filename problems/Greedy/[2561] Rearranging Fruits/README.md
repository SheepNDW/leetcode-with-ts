## 2561. Rearranging Fruits

如果有些元素在兩個陣列裡都成對出現過，顯然我們不會去移動他們。我們先用一個 hash，記錄每種元素在兩個陣列裡的頻次差值，例如 `map[3] = 2`，表示數字 3，在籃子 1 裡比在籃子 2 多了 2 次，反之如果 `map[4] = -3`，就表示數字 4 在籃子 1 裡比在籃子 2 少了 3 次。

為了讓最後每個元素能在調整後，出現在兩陣列中的頻次相同，那麼雜湊表中的 value ，無論正負都必須為偶數，否則就無解。

接著我們通過這個雜湊表，根據 value/2 的值寫出兩個陣列 A、B，可以知道陣列 A 有哪些元素需要換到 B 裡，以及陣列 B 有哪些元素需要換到 A 裡。我們把他們各自排序後記作：

```
A: X X X
B: Y Y Y
```

根據規則，每次操作 AB 中的元素交換，代價是 `min(X, Y)`，所以我們要充分利用較小的元素來去交換大的元素，假設在上面 AB 裡全域最小的元素是 A1，那麼它必然會與 B 的最大元素進行對調。再接下來，假設全域第二小的元素是 B1，那麼它必然會與 A 的最大元素進行對調。再記下來，假設全域第三小的元素是 B2，那麼它必然與 A 的第二大元素進行對調.... 假設 A 和 B 裡各自都有 n 個元素，那麼我們進行 n 次對換的代價，其實就是 AB 陣列裡較小的一半（n個）元素。所以我們只需要將 AB 混合起來，取較小的一半元素之和即可。

不過要注意，還有另外一種策略，假設初始狀態下，存在一個全域最小的元素 x，但它在兩個籃子中出現的頻次相等，因此雖然理論上並不需要去換到它，但如果 x 參與了交換，且之前參與交換的代價大於 2 * x，那我們就可以利用 x 當作交換的媒介。例如我們想將 a 和 b 交換，代價是 a，但是我們將步驟改成 a 與 x 交換，然後 x 與 b 交換，代價是 2 * x，這個 2 * x 可能比 a 還要小，因此我們需要在計算代價時，考慮這個情況。

最後計算答案時就是將 AB 陣列混合取最小的 n 個元素，每個再與 2x 比較，最終累加起來。
