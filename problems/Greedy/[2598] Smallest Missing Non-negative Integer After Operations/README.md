## 2598. Smallest Missing Non-negative Integer After Operations

我們對一個元素無論進行多少次加減操作，都不會改變其對於 `value` 的餘數。因此我們可以發現只要元素對於 `value` 的餘數為 `0`，我們就可以通過加減操作將其變為 `0`。同理，只要元素對於 `value` 的餘數為 `1`，我們就可以通過加減操作將其變為 `1`，依此類推可以推到是否能構建出 `value - 1`。

假設有元素對於 `value` 的餘數為 1，我們可以通過加減操作將其變為 `1`，`1 + value`，`1 + 2 * value`，`1 + 3 * value`，...。因此我們可以發現對於餘數為 `i` 的元素，我們可以構建出 `i + k * value` (k >= 0) 的數字。

接下來就是去建一個長度為 `value` 的陣列 `count`，`count[i]` 代表對於餘數為 `i` 的元素個數。接著掃過一次 `count` 找到最小的 `count[i]`，假設最小的 `count[i]` 為 `m`，那麼我們就可以構建出 `i + k * value` (0 <= k < m) 的數字，而 `i + m * value` 就是我們要找的答案。
