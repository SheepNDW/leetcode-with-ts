## 442. Find All Duplicates in an Array

* `Indexing sort`

陣列元素規定了是從 `1 ~ n`，也就是說如果將正整數 `1~n` 按照順序放入 `nums[1] ~ nums[n]` 中，沒有對到位的元素 (`nums[i] != i`) 就是要找的“目標”。

對於“將正整數 `1~n` 依序放入 `nums[1] ~ nums[n]` 中”，有個典型時間複雜度 O(n)、空間複雜度 O(1) 的方法：

遍歷所有 `nums[i]`，發現如果 `nums[i] != i` 時，說明目前的 `nums[i]` 這個數沒有在對的位置上。於是我們交換 `nums[i] 和 nums[nums[i]]` 的位置，這樣做會讓原本的 `nums[i]` 移動到它該在的位置，同時 `nums[i]` 有了新的值，需要再重新進行判斷、交換的過程。直到 `nums[i] == nums[nums[i]]`，代表 `nums[i]` 已經歸位，對於 `i` 這個位置不能再進行任何操作，於是跳過目前的 `i`。

所有元素都遍歷結束後，陣列元素會被盡可能的被歸位在應該出現的順序位置上，接下來只要再掃一次，找到 `nums[i] != i` 的元素，根據題意這就是重複的元素。

```
[4,3,2,7,8,2,3,1]

 1 2 3 4 5 6 7 8
[1,2,3,4,3,2,7,8]
```
