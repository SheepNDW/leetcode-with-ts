## 2434. Using a Robot to Print the Lexicographically Smallest String

題目的操作是：從頭開始依序讀取字串 s，每次可以選擇將當前字元推入一個 stack（即暫存區），或將 stack 頂部的字元彈出並印出。我們要設計出一組操作流程，讓最終印出的字串在所有可能結果中字典序最小。

我們上來先從貪心思想起手，思考如果 `s` 終有一個字元 `'a'` 在索引 `i` 處，它一定應該是最終答案的第一個字元。所以我們在遇到 `'a'` 之前，所有的字元，即 `s[0:i-1]` 都應該依次存入 stack 但是不應該彈出。直到我們遇到那個 `'a'`，將其放入 stack 後馬上彈出，這樣才能得到一個以 `'a'` 開頭的最小字典序字串。

此時需要考慮的是 `s[i+1]`，並且注意到之前的 `s[0:i-1]` 已經逆序存於 stack 中。我們有兩個選擇：立即彈出目前的 stack 頂部字元，或者將 `s[i+1]` 也放入 stack 中（立即彈出或保留）。我們的策略就是觀察此時的頂部字元是否夠小？如果 `s[i+1]` 及它之後全域最小的字元（假設還是 `'a'`，位置在 `j`），它比 stack 頂部字元還小，根據貪心的原則，我們必然至少要繼續將字元加入 stack 直到遇到 `s[j]`，接下來就是一個 push 和 pop 將 `s[j]` 印出來。反之，如果 `s[i+1]` 即它之後的全域最小字元比 stack 頂部字元還大，那麼印出目前 stack 的頂部字元自然是最佳的選擇。

所以本題需要先預處理一個後綴陣列 `smallest`，其中 `smallest[i]` 表示從 `s[i]` 到 `s[n-1]` 的最小字元。這樣我們就可以在每次遇到新字元 `s[i]` 時，就可以快速查詢 `smallest[i]` 和 stack 頂部字元的大小關係，決定是否要彈出 stack 還是繼續將 `s[i]` 放入 stack。
