## 1190. Reverse Substrings Between Each Pair of Parentheses

解法 1：Simulation

模擬整個反轉過程。用一個變數 `res` 記錄字母，用一個 stack 來標記左右括號的配對。

每當遇到左括號時，就往 stack 推入目前 `res` 長度。遇到右括號時，從 stack 頂部讀取 index，它就是 `res` 裡與之配對的左括號位置。然後將 index 到 res 末尾的字串整體反轉。不動重複上面操作即可。

例如：`'(u(love)i)'`

1. 第一次遇到右括號前，`res = 'ulove'`，stack 中的元素是 `[0, 1]`，此時遇到第一個右括號，代表 res[1:end] 需要反轉，所以得到 `res = 'uevol'`。
2. 第二次遇到右括號前，`res = 'uevoli'`，stack 中的元素是 `[0]`，此時遇到第二個右括號，代表 res[0:end] 需要反轉，所以得到 `res = 'iloveu'`。

考慮到很多字母加入 `res` 後又要逆序，所以時間複雜度是 $O(n^2)$。

解法 2：反向模擬

我們看一下這個例子：`abc(def(ghi)k)`。

當我們順著讀取 abc 後，看到後面的 `(...)` 時，可以知道括號內的 `def(ghi)k` 解析之後的結果一定最終是反向輸出的，那麼我們乾脆就反向讀取它們，從 k 開始往前讀。但是要怎麼樣可以找到 k 呢？那就是從這個左括號所對應的右括號開始往左走。

然後我們又遇到了更深一層的括號 `ghi`，同理我們知道這個更深一層的括號解析之後也是反向輸出的，我們就繼續反向讀取它，也就是從 g 開始往右讀。那麼要找到 g，就是從這個右括號對應的左括號開始往右走。於是就能順著把 `ghi` 都讀完。

再接著我們會碰到 ghi 的右括號，此時已經把這對括號讀完了，應該繼續讀之前被暫停的 f。要怎麼定位到 f 呢？其實就是再跳回原來的左括號，但此時要往左走。

於是我們發現了一個規律，當你進入一個更深一層的括號時，就跳到括號的另一邊反向讀取，當你離開這個括號時，也要跳到括號的另一邊反向離開。
